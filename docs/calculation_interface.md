# Factory Planner - Calculation-Interface Documentation

This describes the API available from within Factory Planner that allows for the implementation of a model for solving the requisite recipe calculations. These functions are all found under the global `calculation` variable. The relevant ones are explained below.

> **Note:** When the documentation calls a data structure a `custom prototype`, it refers to a table that is specific to Factory Planner and that describes a certain prototype of a certain type. This is **not** a reference to a prototype that you would get from the Factorio API, like [LuaRecipePrototype](https://lua-api.factorio.com/latest/LuaRecipePrototype.html) for example. It is instead a table that is generated by Factory Planner itself, and contains a set of data that is not identical to the base game prototypes, and differs in format under certain circumstances. They *can not* be modified, as that would break everything that uses them. These docs will not lay out those prototype tables, as they are quite large and contain a lot of different things. If you want to take a look at what they contain, I suggest either logging them using `llog()` or installing the [VSCode debugger](https://marketplace.visualstudio.com/items?itemName=justarandomgeek.factoriomod-debug).

> **Note:** When this documentation referrs to a `line`, it assumes a normal recipe line, meaning one without a subfloor. Lines with sublfoors need to be handled differently, and will be explicitly mentioned.

> **Note:** This documentation only describes the interface that is provided, not how to actually go about solving. If you have any questions about this, feel free to take a look at how the implementation of the sequential solver, or ask @Therenas on the [Discord](https://discord.gg/ABqNEQc).

## `subfactory_data`

> **Note:** This is the data your top level solver function will recieve. It contains all the data necessary to carry out your calculations. How you go through it is up to you, what matters is that the results are returned to the proper places, detailed in the two functions below (`set_subfactory/line_result`). Some of this data might not be relevant in your way of solving, you don't necessarily need to consider all of it.

> **Note:** Be aware that the floors in this mod are recursive in nature. Every line on a floor can represent a subfloor of its own, which in turn can have lines on it that represent a subfloor themselves. Due to this, the data in this table is nested in a recursive way, and your solver will need a recursive way to go through it. You however won't need to compose a recursive table yourself to return your results, as will become apparent in the two functions below. I'll note when recursion occurs in the docs right below.

- `player_index` - The index of the player that this calculation is being run for. You'll need this when feeding the calculated results back to the mod.
- `top_level_products` - An array containing all the top level products the user configured. These are the products that this subfactory should actually produce. Each element in this array has the following fields:
  - `proto` - A custom prototype that specifies the item/fluid that should be produced.
  - `amount` - The actual amount of this item that should be produced.
- `top_floor` - This is a table that is the jumping-off point for your solver. It has the following fields:
  - `id` - The internal id of this floor. You'll need this when feeding the calculated results back to the mod.
  - `lines` - An array containing all the lines on this floor. What data each line contains depends on whether it is a simple recipe line, or whether it is a line representing a subfloor. For simplicity, unless otherwise noted, the fields below only appear on simple recipe lines.
    - `id` [Present on both types of line] - The internal id of this line. You'll need this when feeding the calculated results back to the mod.
    - `recipe_proto` [Present on both types of line] - A custom prototype that specifies this line's recipe.
    - `subfloor` [Present only on lines with subfloors] - A reference to the data table of the floor that is attached to this line. This is the point where recursion occurs. The content of this field is identical in structure to `top_floor`.
    - `timescale` - The timescale that the user configured for this subfactory. This will be needed when calling certain `calculation.util` functions.
    - `production_type` - This is either `"produce"` or `"consume"`. It tells you whether this recipe's purpose is to *produce* the desired products or to *consume* otherwise useless byproducts.
    - `percentage` - A user-configured value (it can be higher than 100) that directly influences this line's output. It specifies how much of the production you determine to be necessary to fulfill the demand should actually be carried out. As an example, if your recipe needs to satisfy 200 electronic circuits, but the percentage is set at 120 percent, the recipe should actually produce 240 circuits.
    - `machine_proto` - A custom prototype that specifies the machine that this line uses.
    - `machine_limit` *(optional)* - A user-configured value that aims to limit the total machines that can be used. It is not necessarily configured on every line. It has two components, which are:
      - `limit` - A numeric value that limits the amount of machines that can be used. The solver can't use more machines than this number, even if this means some of the demand remains unfulfilled. If the solver needs fewer machines than this limit, it should use fewer.
      - `hard_limit` *(optional)* - A boolean value that modifies the behavior of the above `limit`. It can thus only be present when a limit is as well, but doesn't have to be. When a hard limit is enabled, the solver can only use the exact amount of machines `limit` specifies. This can lead to overproduction, which is expected.
    - `priority_product_proto` *(optional)* - A user-configured value for lines with more than one relevant product. It specifies which of the relevant product's demands should be fulfilled precisely. If this is not configured, recipes should always aim to fully fulfill all relevant product demands, even if this leads to overproduction for one or more of them.
    - `beacon_consumption` - The energy consumption for this line's beacons. This value can simply be added to the total energy consumption of the line.
    - `fuel_proto` *(optional)* - A custom prototype that specifies the fuel this line uses, if it uses fuel at all.
    - `total_effects` - The complete module effects that apply to this recipe and machine. This is a table that will always contain 4 keys (`consumption`, `speed`, `productivity`, `pollution`) that have a numeric value assigned to them. That value might be 0, and can be negative. The value is a bonus, meaning a productivity value of `0.4` means this recipe is influenced by `+40%` productivity. This will be needed when calling certain `calculation.util` functions.

## `calculation.interface.set_subfactory_result()`

> **Note:** This is the first of two functions that allow you to import the results of your calculations back into the data model. Please refer to the annotated screenshot if you want to know where in the interface this data will actually go. This particular function needs to be called once for the `subfactory_data` that is provided as it sets the top level data of this subfactory.

> **Note:** The calculation interface retains which subfactory is currently being updated. This function thus only needs to know the player that the calculations are run for and can associate them with the correct subfactory.

> **Note:** This is the point where the `class` structure comes into play, which is documented further down. The `Product`, `Byproduct` and `Ingredient` result fields expect this format, so you might want to consider using the provided `structures` functions to get the data into shape.

- The table you pass to this function should contain the following sets of data:
  - `player_index` - The index of the player that these calculations have been run for. `subfactory_data` provides this to you.
  - `energy_consumption` [1] - The total electrical energy consumption of this subfactory. Should be pretty-self explanatory.
  - `pollution` [2] - The total amount of pollution produced by this subfactory, excluding any external electrical energy production of course.
  - `Product` [3] - This part of the results works a bit counter-intuitively (read: bad implementation). It is a table of tables that follows the `class` format. However, as products are intially defined by the user, it differs from `Byproduct` and `Ingredient` in what the amounts in the class mean. The amounts here signal the amount of items *missing* to fully satisfy the users demand for that product. As an example, if this class specifies an amount of 40 electronic circuits, it means that there are 40 circuits missing to fully satisfy the demand. Following this logic, a totally empty class means that the demand for every product is fully satisfied.
  - `Byproduct` [4] - A table of tables that follows the `class` format. The amounts associated to the items in that class specify the amounts of byproduct the whole subfactory produces.
  - `Ingredient` [5] - A table of tables that follows the `class` format. The amounts associated to the items in that class specify the amounts of ingredient that the whole subfactory requires as input.

## `calculation.interface.set_line_result()`

> **Note:** This is the second of two functions that allow you to import the results of your calculations back into the data model. Please refer to the annotated screenshot if you want to know where in the interface this data will actually go. This particular function needs to be called once for every line in the entire subfactory.

> **Note:** Even though the structure of subfactories is recursive in nature, this function working on any line independently allows you to return the line data right where you got it without having to worry about packing it back into a recursive table structure.

> **Note:** The calculation interface retains which subfactory is currently being updated. This function thus only needs to know the player that the calculations are run for and can associate them with the correct subfactory. In addition, it needs the id's of both the floor and line so it can update the correct line within that subfactory.

> **Note:** This is the point where the `class` structure comes into play, which is documented further down. The `Product`, `Byproduct` and `Ingredient` result fields expect this format, so you might want to consider using the provided `structures.class` functions to get your data into shape.

- The table you pass to this function should contain the following sets of data:
  - `player_index` - The index of the player that these calculations have been run for. `subfactory_data` provides this to you.
  - [To be continued]

## Utility functions

> **Note:** These are functions that you can use in your solver so you don't have to worry too much about the details of how certain values like energy consumption or pollution need to be calculated. This doesn't mean you will have to use every single one of these, as some might not apply to your way of solving.

### `calculation.util.determine_crafts_per_tick()`

- This function needs to be determined once for each individual line. It returns the `crafts_per_tick` for the current line, which basically describes how many crafts a single machine will execute per tick. This is needed in several differnt calculations, so for performance reasons, it is determined once at the beginning and then used later in other `calculation.util` function calls.
- It has the following arguments, in order:
  - `machine_proto` - A custom prototype that is provided for each line.
  - `recipe_proto` - A custom prototype that is provided for each line.
  - `total_effects` - A table of module effects that is provided for each line.

### `calculation.util.determine_machine_count()`

- This function returns the amount of machines needed to produce the required amount of items in the given circumstances.
- It has the following arguments, in order:
  - `crafts_per_tick` - A value that needs to be determined using the `determine_crafts_per_tick` function first.
  - `production_ratio` - A value that refers to the precise amount of times the recipe of the current line needs to be run to produce the desired amount. As an example, if you require 15 copper cables, and their recipe produces 3 cables at a time, the `production ratio` of this line would be `15/3=5`.
  - `timescale` - A value that is provided on each line.
  - `is_rocket_silo` - A value that can be found on the custom `machine` prototype that is provided for each line.

### `calculation.util.determine_production_ratio()`

- This function returns the `production_ratio` that follows from the given `machine_limit` in the given circumstances. This basically does the reverse of `determine_machine_count` in that you provide an amount of machines and it returns a `production_ratio`.
- It has the following arguments, in order:
  - `crafts_per_tick` - A value that needs to be determined using the `determine_crafts_per_tick` function first.
  - `machine_limit` - A value that specifies the exact amount of machines that the current line should use. This is useful when incorporating a user-determined limit on the number of machines per line.
  - `timescale` - A value that is provided on each line.
  - `is_rocket_silo` - A value that can be found on the custom `machine` prototype that is provided for each line.

### `calculation.util.determine_prodded_amount()`

- This function returns the amount of the given item that will be produced/consumed after applying the appropriate productivity bonuses. *(I am not sure what exactly this expresses in simple terms at the moment.)*
- It has the following arguments, in order:
  - `item` - A table that describes an item using its type, name, and amount. This table is obtained from the products/ingredients of a custom `recipe` prototype, meaning the amount will describe how many of this item are produced/consumed when crafting the recipe once.
  - `crafts_per_tick` - A value that needs to be determined using the `determine_crafts_per_tick` function first.
  - `total_effects` - A table of module effects that is provided for each line.

### `calculation.util.determine_energy_consumption()`

- This function returns the amount of energy the current line consumes. This is applicable for all kinds of energy, meaning it needs to be converted to an amount of fuel if the current line does not use electrical energy.
- It has the following arguments, in order:
  - `machine_proto` - A custom prototype that is provided for each line.
  - `machine_count` - A value that specifies the amount of machines this line needs to run. This should be a decimal number, as you'll rarely need an exact number of machines to satisfy the demand, and the machine that is not fully needed will idle some of the time, which this takes into account.
  - `total_effects` - A table of module effects that is provided for each line.

### `calculation.util.determine_pollution()`

- This function returns the amount of pollution the current line produces. This is applicable to all kinds of energy, pollution is not limited to machines that consume electrical energy.
- It has the following arguments, in order:
  - `machine_proto` - A custom prototype that is provided for each line.
  - `recipe_proto` - A custom prototype that is provided for each line.
  - `fuel_proto` - A custom prototype that is provided for each line.
  - `total_effects` - A table of module effects that is provided for each line.
  - `energy_consumption` - A value that specifies the amount of energy that this line consumes. This needs to be determined using the `determine_energy_consumption` function first.

### `calculation.util.determine_fuel_amount()`

- This function returns the amount of fuel the current line requires to function. This is not relevant for every line, as only some machines run on fuel.
- It has the following arguments, in order:
  - `energy_consumption` - A value that specifies the amount of energy that this line consumes. This needs to be determined using the `determine_energy_consumption` function first.
  - `burner` - A value that can be found on the custom `machine` prototype that is provided for each line.
  - `fuel_value` - A value that can be found on the custom `fuel` prototype that is provided for each line whose machine consumes fuel.
  - `timescale` - A value that is provided on each line.

## Structure functions

> **Note:** There is a second collection of functions that are found under the `structures` global variable. It's up to you whether you want to use them, but they are helpful as some parts of the API expect data to be formatted in the way these functions generate.

> **Note:** There are two types of data structures, one of which builds upon the other. There is the `class` structure that contains the different types (item, fluid, entity) of items for one kind of item (Product, Byproduct, Ingredient), with convenient functions to manipulate them. Then, there is the `aggregate` structure, which is a convenient table that contains all the types of data you generate in your solver. This wrapper allows you to pass all this data between the different functions that might want to manipulate it.

### `structures.class.init()`

- This function generates a table containing 3 empty tables, one for each of `item`, `fluid` and `entity`. A class is a container that allows you to centralize and manipulate item amounts for a certain *class* of items (Product, Byproduct, Ingredient). You need to call this so you can call the functions with actual functionality on the `class` table that is returned.

### `structures.class.add()`

- This function works on the given class, adding to it the given item with the relevant amount. More detail on how the relevant amount is determined below.
- It has the following arguments, in order:
  - `class` - The collection that you want to add to.
  - `item` - A table that describes an item using its type, name, and amount. If the item is already present in this class, the amount is added to the exising amount. If not, a new item is created.
  - `amount` *(optional)* - If this argument is provided, the function will add this amount to the class, ignoring the amount that is possibly present on the `item` table.

### `structures.class.subtract()`

- This function works basically identically to `class.add`, with the difference that it subtracts the relevant amount instead of adding it.

### `structures.class.balance_items()`

- This function is hard to explain.

### `structures.class.to_array()`

- This function turns the given class into a flat array, making it easy to iterate through it with a single for loop.
- It has the following argument:
  - `class` - The collection that you want to iterate over.

### `structures.class.copy()`

- This function deepcopies the given class. It has better performance than a generic deepcopy function as it knows the exact structure of the class and can thus avoid a lot of overhead.
- It has the following argument:
  - `class` - The collection that you want to copy.

### `structures.class.count()`

- This function counts the number of elements that this class contains. As a class has a nested structure, using `#class` would not produce the correct result.
- It has the following argument:
  - `class` - The collection whose elements you want to count.

### `structures.aggregate.init()`

- This function generates a blank table structure, with the elements listed below. It can be used as a wrapper for passing data that you calculated between functions that will each manipulate some part of them. For example, an aggregate can be used for the subfactory as a whole, with each individual line being given the overarching aggregate and adding their own energy consumption and pollution to it.
- It contains `player_index`, `floor_id`, `machine_count`, `energy_consumption`, `pollution`, `production_ratio`, `uncapped_production_ratio`, `Product`, `Byproduct`, and `Ingredient`, the first two being filled in with the given arguments, and the last three being blank `class`es.
- It has the following arguments, in order:
  - `player_index` - A value that is provided with the subfactory data.
  - `floor_id` - A value that is provided with every set of floor data.

### `structures.aggregate.add()`

- This function adds the given item to the given class of the given aggregate. It is basically a shortcut to extracting the appropriate class from the aggreate yourself and calling `class.add`.
- It has the following arguments, in order:
  - `aggregate` - The collection you want to add to.
  - `class_name` - The name of the class you want to add to. This is either `Product`, `Byproduct`, or `Ingredient`.
  - `item` - A table that describes an item using its type, name, and amount. If the item is already present in this class, the amount is added to the exising amount. If not, a new item is created.
  - `amount` *(optional)* - If this argument is provided, the function will add this amount to the class, ignoring the amount that is possibly present on the `item` table.

### `structures.aggregate.subtract()`

- This function works basically identically to `aggregate.add`, with the difference that it subtracts the relevant amount instead of adding it.
